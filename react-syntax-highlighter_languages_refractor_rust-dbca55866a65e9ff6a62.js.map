{"version":3,"sources":["webpack:///./node_modules/refractor/lang/rust.js"],"names":["rust","Prism","languages","comment","pattern","lookbehind","string","greedy","alias","keyword","attribute","number","inside","punctuation","operator","module","exports","displayName","aliases"],"mappings":"+FAMA,SAASA,EAAKC,GAOZA,EAAMC,UAAUF,KAAO,CACrBG,QAAS,CAAC,CACRC,QAAS,4BACTC,YAAY,GACX,CACDD,QAAS,mBACTC,YAAY,IAEdC,OAAQ,CAAC,CACPF,QAAS,uCACTG,QAAQ,GACP,CACDH,QAAS,0BACTG,QAAQ,IAEV,KAAQ,CACNH,QAAS,wEACTI,MAAO,UAET,sBAAuB,CACrBJ,QAAS,YACTI,MAAO,UAETC,QAAS,6TACTC,UAAW,CACTN,QAAS,aACTG,QAAQ,EACRC,MAAO,aAET,SAAY,CAAC,eACb,oBACA,cAAe,CACbJ,QAAS,OACTI,MAAO,YAGTG,OAAQ,kKAER,iBAAkB,CAChBP,QAAS,uBACTQ,OAAQ,CACNC,YAAa,QACbC,SAAU,SAGdD,YAAa,mCACbC,SAAU,uDAzDdC,EAAOC,QAAUhB,EACjBA,EAAKiB,YAAc,OACnBjB,EAAKkB,QAAU","file":"react-syntax-highlighter_languages_refractor_rust-dbca55866a65e9ff6a62.js","sourcesContent":["'use strict';\n\nmodule.exports = rust;\nrust.displayName = 'rust';\nrust.aliases = [];\n\nfunction rust(Prism) {\n  /* TODO\n  Add support for Markdown notation inside doc comments\n  Add support for nested block comments...\n  Match closure params even when not followed by dash or brace\n  Add better support for macro definition\n  */\n  Prism.languages.rust = {\n    comment: [{\n      pattern: /(^|[^\\\\])\\/\\*[\\s\\S]*?\\*\\//,\n      lookbehind: true\n    }, {\n      pattern: /(^|[^\\\\:])\\/\\/.*/,\n      lookbehind: true\n    }],\n    string: [{\n      pattern: /b?r(#*)\"(?:\\\\.|(?!\"\\1)[^\\\\\\r\\n])*\"\\1/,\n      greedy: true\n    }, {\n      pattern: /b?\"(?:\\\\.|[^\\\\\\r\\n\"])*\"/,\n      greedy: true\n    }],\n    \"char\": {\n      pattern: /b?'(?:\\\\(?:x[0-7][\\da-fA-F]|u{(?:[\\da-fA-F]_*){1,6}|.)|[^\\\\\\r\\n\\t'])'/,\n      alias: 'string'\n    },\n    'lifetime-annotation': {\n      pattern: /'[^\\s>']+/,\n      alias: 'symbol'\n    },\n    keyword: /\\b(?:abstract|alignof|as|async|await|be|box|break|const|continue|crate|do|dyn|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|match|mod|move|mut|offsetof|once|override|priv|pub|pure|ref|return|sizeof|static|self|Self|struct|super|true|trait|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\\b/,\n    attribute: {\n      pattern: /#!?\\[.+?\\]/,\n      greedy: true,\n      alias: 'attr-name'\n    },\n    \"function\": [/\\w+(?=\\s*\\()/, // Macros can use parens or brackets\n    /\\w+!(?=\\s*\\(|\\[)/],\n    'macro-rules': {\n      pattern: /\\w+!/,\n      alias: 'function'\n    },\n    // Hex, oct, bin, dec numbers with visual separators and type suffix\n    number: /\\b(?:0x[\\dA-Fa-f](?:_?[\\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(\\d(?:_?\\d)*)?\\.?\\d(?:_?\\d)*(?:[Ee][+-]?\\d+)?)(?:_?(?:[iu](?:8|16|32|64)?|f32|f64))?\\b/,\n    // Closure params should not be confused with bitwise OR |\n    'closure-params': {\n      pattern: /\\|[^|]*\\|(?=\\s*[{-])/,\n      inside: {\n        punctuation: /[|:,]/,\n        operator: /[&*]/\n      }\n    },\n    punctuation: /->|\\.\\.=|\\.{1,3}|::|[{}[\\];(),:]/,\n    operator: /[-+*\\/%!^]=?|=[=>]?|&[&=]?|\\|[|=]?|<<?=?|>>?=?|[@?]/\n  };\n}"],"sourceRoot":""}