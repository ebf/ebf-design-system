{"version":3,"sources":["webpack:///./node_modules/refractor/lang/stylus.js"],"names":["stylus","Prism","inside","url","string","pattern","greedy","interpolation","func","important","keyword","lookbehind","hexcode","number","operator","punctuation","alias","delimiter","rest","languages","comment","atrule","variable","statement","property","selector","module","exports","displayName","aliases"],"mappings":"6FAMA,SAASA,EAAOC,IAGd,SAAWA,GACT,IAAIC,EAAS,CACXC,IAAK,uBACLC,OAAQ,CACNC,QAAS,gDACTC,QAAQ,GAEVC,cAAe,KAEfC,KAAM,KAENC,UAAW,+BACXC,QAAS,CACPL,QAAS,4DACTM,YAAY,GAEdC,QAAS,iBACTC,OAAQ,oBACR,QAAW,qBACXC,SAAU,CAEV,oGACAC,YAAa,iBAEfb,EAAsB,cAAI,CACxBG,QAAS,iBACTW,MAAO,WACPd,OAAQ,CACNe,UAAW,CACTZ,QAAS,QACTW,MAAO,eAETE,KAAMhB,IAGVA,EAAa,KAAI,CACfG,QAAS,oBACTH,OAAQ,CACN,SAAY,SACZgB,KAAMhB,IAGVD,EAAMkB,UAAUnB,OAAS,CACvBoB,QAAS,CACPf,QAAS,qCACTM,YAAY,GAEd,qBAAsB,CACpBN,QAAS,aACTM,YAAY,EACZT,OAAQ,CACNmB,OAAQ,WACRH,KAAMhB,IAGV,uBAAwB,CACtBG,QAAS,sDACTM,YAAY,EACZT,OAAQ,CACNoB,SAAU,OACVJ,KAAMhB,IAGVqB,UAAW,CACTlB,QAAS,kDACTM,YAAY,EACZT,OAAQ,CACNQ,QAAS,OACTQ,KAAMhB,IAKV,uBAAwB,CACtBG,QAAS,0HACTM,YAAY,EACZT,OAAQ,CACNsB,SAAU,CACRnB,QAAS,WACTH,OAAQ,CACNK,cAAeL,EAAOK,gBAG1BW,KAAMhB,IAMVuB,SAAU,CACRpB,QAAS,uNACTM,YAAY,EACZT,OAAQ,CACNK,cAAeL,EAAOK,cACtBQ,YAAa,UAGjBP,KAAMN,EAAOM,KACbJ,OAAQF,EAAOE,OACfG,cAAeL,EAAOK,cACtBQ,YAAa,iBApGjB,CAsGGd,GA7GLyB,EAAOC,QAAU3B,EACjBA,EAAO4B,YAAc,SACrB5B,EAAO6B,QAAU","file":"react-syntax-highlighter_languages_refractor_stylus-a9c98f9cfad64b21ea6b.js","sourcesContent":["'use strict';\n\nmodule.exports = stylus;\nstylus.displayName = 'stylus';\nstylus.aliases = [];\n\nfunction stylus(Prism) {\n  ;\n\n  (function (Prism) {\n    var inside = {\n      url: /url\\(([\"']?).*?\\1\\)/i,\n      string: {\n        pattern: /(\"|')(?:(?!\\1)[^\\\\\\r\\n]|\\\\(?:\\r\\n|[\\s\\S]))*\\1/,\n        greedy: true\n      },\n      interpolation: null,\n      // See below\n      func: null,\n      // See below\n      important: /\\B!(?:important|optional)\\b/i,\n      keyword: {\n        pattern: /(^|\\s+)(?:(?:if|else|for|return|unless)(?=\\s+|$)|@[\\w-]+)/,\n        lookbehind: true\n      },\n      hexcode: /#[\\da-f]{3,6}/i,\n      number: /\\b\\d+(?:\\.\\d+)?%?/,\n      \"boolean\": /\\b(?:true|false)\\b/,\n      operator: [// We want non-word chars around \"-\" because it is\n      // accepted in property names.\n      /~|[+!\\/%<>?=]=?|[-:]=|\\*[*=]?|\\.+|&&|\\|\\||\\B-\\B|\\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\\b/],\n      punctuation: /[{}()\\[\\];:,]/\n    };\n    inside['interpolation'] = {\n      pattern: /\\{[^\\r\\n}:]+\\}/,\n      alias: 'variable',\n      inside: {\n        delimiter: {\n          pattern: /^{|}$/,\n          alias: 'punctuation'\n        },\n        rest: inside\n      }\n    };\n    inside['func'] = {\n      pattern: /[\\w-]+\\([^)]*\\).*/,\n      inside: {\n        \"function\": /^[^(]+/,\n        rest: inside\n      }\n    };\n    Prism.languages.stylus = {\n      comment: {\n        pattern: /(^|[^\\\\])(\\/\\*[\\s\\S]*?\\*\\/|\\/\\/.*)/,\n        lookbehind: true\n      },\n      'atrule-declaration': {\n        pattern: /(^\\s*)@.+/m,\n        lookbehind: true,\n        inside: {\n          atrule: /^@[\\w-]+/,\n          rest: inside\n        }\n      },\n      'variable-declaration': {\n        pattern: /(^[ \\t]*)[\\w$-]+\\s*.?=[ \\t]*(?:(?:\\{[^}]*\\}|.+)|$)/m,\n        lookbehind: true,\n        inside: {\n          variable: /^\\S+/,\n          rest: inside\n        }\n      },\n      statement: {\n        pattern: /(^[ \\t]*)(?:if|else|for|return|unless)[ \\t]+.+/m,\n        lookbehind: true,\n        inside: {\n          keyword: /^\\S+/,\n          rest: inside\n        }\n      },\n      // A property/value pair cannot end with a comma or a brace\n      // It cannot have indented content unless it ended with a semicolon\n      'property-declaration': {\n        pattern: /((?:^|\\{)([ \\t]*))(?:[\\w-]|\\{[^}\\r\\n]+\\})+(?:\\s*:\\s*|[ \\t]+)[^{\\r\\n]*(?:;|[^{\\r\\n,](?=$)(?!(\\r?\\n|\\r)(?:\\{|\\2[ \\t]+)))/m,\n        lookbehind: true,\n        inside: {\n          property: {\n            pattern: /^[^\\s:]+/,\n            inside: {\n              interpolation: inside.interpolation\n            }\n          },\n          rest: inside\n        }\n      },\n      // A selector can contain parentheses only as part of a pseudo-element\n      // It can span multiple lines.\n      // It must end with a comma or an accolade or have indented content.\n      selector: {\n        pattern: /(^[ \\t]*)(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\))?|\\{[^}\\r\\n]+\\})+)(?:(?:\\r?\\n|\\r)(?:\\1(?:(?=\\S)(?:[^{}\\r\\n:()]|::?[\\w-]+(?:\\([^)\\r\\n]*\\))?|\\{[^}\\r\\n]+\\})+)))*(?:,$|\\{|(?=(?:\\r?\\n|\\r)(?:\\{|\\1[ \\t]+)))/m,\n        lookbehind: true,\n        inside: {\n          interpolation: inside.interpolation,\n          punctuation: /[{},]/\n        }\n      },\n      func: inside.func,\n      string: inside.string,\n      interpolation: inside.interpolation,\n      punctuation: /[{}()\\[\\];:.]/\n    };\n  })(Prism);\n}"],"sourceRoot":""}